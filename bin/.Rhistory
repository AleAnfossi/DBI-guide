Line = rep(row_name, length(column_names))  # Use the second row's name for the legend
)
# Create the plot
ggplot(plot_data, aes(x = Configuration, y = Value)) +
geom_bar() +
labs(x = "Clustering algorithm", y = "DBI result", title = "Davies-Bouldin Index Evaluations", color = "DBI Configuration") +
theme_grey() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 14),  # Rotate x-axis labels by 45 degrees and set font size
plot.title = element_text(size = 20),       # Title font size
axis.title.x = element_text(size = 16),     # X axis label font size
axis.title.y = element_text(size = 16),     # Y axis label font size
axis.text.y = element_text(size = 14),      # Y axis tick labels font size
legend.title = element_text(size = 16),     # Legend title font size
legend.text = element_text(size = 14)       # Legend text font size
)
ggplot(plot_data, aes(x = Configuration, y = Value)) +
geom_bar(stat = "identity") +
labs(x = "Clustering algorithm", y = "DBI result", title = "Davies-Bouldin Index Evaluations", color = "DBI Configuration") +
theme_grey() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 14),  # Rotate x-axis labels by 45 degrees and set font size
plot.title = element_text(size = 20),       # Title font size
axis.title.x = element_text(size = 16),     # X axis label font size
axis.title.y = element_text(size = 16),     # Y axis label font size
axis.text.y = element_text(size = 14),      # Y axis tick labels font size
legend.title = element_text(size = 16),     # Legend title font size
legend.text = element_text(size = 14)       # Legend text font size
)
#Script where I load an EHRs document(Spain_cardiac_arrest) and apply the kmeans clustering
#and my DBI function. Then I save everything on a couple of csv files
#!!I had to delete some rows caused by missing data!!
#(rows: 52 203 221 234 298 391)
#Loading data
mydata<-read.csv("Spain_cardiac_arrest.csv")
#getting kmeans labels
km_labels<-kmeans_labels(mydata)
#getting hclust labels
hc_labels<-hclust_labels(mydata)
#Getting dbscan parameters
eps<- 3.5             #Radius
minPts<-5            #Minimal number of neighbours
#Setting the case
case <- "Cardiac_arrest"
#getting dbscan labels
dbsc_lab<-dbscan_labels(mydata,eps,minPts,case)
# Calculate the four indexes
indexes<-DBI_EHRs(mydata,km_labels,hc_labels,dbsc_lab)
#binding clusterings for printing
labels<-list(mydata,km_labels,hc_labels,dbsc_lab)
#Find the highest DBI scores
highest_DBI_result <- find_highest_DBI(indexes)
#Calculate cardinality of clusters
cardinality_proportions <- calculate_cardinality_proportion(mydata,km_labels,hc_labels,dbsc_lab)
#Print and plot the result
filename_percentages<-paste0("Cardiac_arrest_cluster_percentages_Plot.pdf")
pdf(filename_percentages)
plot_cluster_percentages(cardinality_proportions)
dev.off()
#Compare clusterings in a chart
compare_clusterings(labels)
#Print the DBI results
# Convert the first four rows into a format suitable for plotting
#rows_to_plot <- indexes[1:4, ]  # Extract the first four rows
#column_names <- colnames(indexes)  # Get the column names (from kmeans2 onwards)
# Get the actual row names from the data frame
#row_names <- rownames(indexes)[1:4]
# Create a data frame for plotting, using the row names for the legend
#plot_data <- data.frame(
#  Configuration = rep(column_names, times = 4),
#  Value = c(as.numeric(indexes[1, ]), as.numeric(indexes[2, ]),
#            as.numeric(indexes[3, ]), as.numeric(indexes[4, ])),
#  Line = rep(row_names, each = length(column_names))  # Use row names for the legend)
#filename_dbi_plot<-paste0("Cardiac_arrest_DBI_Plot.pdf")
#pdf(filename_dbi_plot)
# Create the plot, using color to distinguish the lines and row names in the legend
#ggplot(plot_data, aes(x = Configuration, y = Value, color = Line)) +
#  geom_point() +
#  labs(x = "Clustering algorithm", y = "DBI result", title = "Davies-Bouldin Index Evaluations", color="DBI Configuration") +
#  theme_grey()+
#  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels by 45 degrees
#dev.off()
# Print the DBI results for the second row
# Convert only the second row into a format suitable for plotting
rows_to_plot <- indexes[2, , drop = FALSE]  # Extract only the second row
column_names <- colnames(indexes)  # Get the column names (from kmeans2 onwards)
# Get the actual row name for the second row
row_name <- rownames(indexes)[2]
# Create a data frame for plotting, using the row name for the legend
plot_data <- data.frame(
Configuration = column_names,  # Use the column names as x-axis labels
Value = as.numeric(indexes[2, ]),  # Use the second row for the values
Line = rep(row_name, length(column_names))  # Use the second row's name for the legend
)
# Specify the filename for the PDF output
filename_dbi_plot <- paste0("Cardiac_arrest_DBI_Plot.pdf")
pdf(filename_dbi_plot)
# Create the plot
ggplot(plot_data, aes(x = Configuration, y = Value)) +
geom_bar(stat = "identity") +#geom_point()
labs(x = "Clustering algorithm", y = "DBI result", title = "Davies-Bouldin Index Evaluations", color = "DBI Configuration") +
theme_grey() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 14),  # Rotate x-axis labels by 45 degrees and set font size
plot.title = element_text(size = 20),       # Title font size
axis.title.x = element_text(size = 16),     # X axis label font size
axis.title.y = element_text(size = 16),     # Y axis label font size
axis.text.y = element_text(size = 14),      # Y axis tick labels font size
legend.title = element_text(size = 16),     # Legend title font size
legend.text = element_text(size = 14)       # Legend text font size
)
dev.off()
#Exctract information DBI uses
extracted_info <- extract_clustering_info(mydata, labels)
# Open a connection to a text file
sink("Spain_cardiac_arrest_info.txt")
# Print the result
print(highest_DBI_result)
# Print cardinality proportions
print(cardinality_proportions)
# Print the information
print(extracted_info)
# Close the connection
sink()
# Add name for saving!! This is the data csv print
write.csv(labels, file="Spain_cardiac_arrest+labels.csv")
# Add name for saving!! This is the DBI evaluation csv print
write.csv(indexes, file="Spain_cardiac_arrest_DBI.csv")
describe_clustering_result(highest_DBI_result,2)
#Script where I load an EHRs document(diabetes_type1) and apply the kmeans clustering
#and my DBI function. Then I save everything on a couple of csv files
#Loading data
mydata<-read.csv("diabetes_type1.csv")
#getting kmeans labels
km_labels<-kmeans_labels(mydata)
#getting hclust labels
hc_labels<-hclust_labels(mydata)
#Getting dbscan parameters
eps<- 25               #radius
minPts<-2             #minimal number of neighbours
#Setting the case
case <- "Diabetes"
#getting dbscan labels
dbsc_lab<-dbscan_labels(mydata,eps,minPts,case)
# Calculate the four indexes
indexes<-DBI_EHRs(mydata,km_labels,hc_labels,dbsc_lab)
#binding clusterings for printing
labels<-list(mydata,km_labels,hc_labels,dbsc_lab)
#Find the highest DBI scores
highest_DBI_result <- find_highest_DBI(indexes)
#Calculate cardinality of clusters
cardinality_proportions <- calculate_cardinality_proportion(mydata,km_labels,hc_labels,dbsc_lab)
#Print and plot the result
filename_percentages<-paste0("Diabetes_cluster_percentages_Plot.pdf")
pdf(filename_percentages)
plot_cluster_percentages(cardinality_proportions)
dev.off()
#Compare clusterings in a chart
compare_clusterings(labels)
#Print the DBI results
# Convert the first four rows into a format suitable for plotting
#rows_to_plot <- indexes[1:4, ]  # Extract the first four rows
#column_names <- colnames(indexes)  # Get the column names (from kmeans2 onwards)
# Get the actual row names from the data frame
#row_names <- rownames(indexes)[1:4]
# Create a data frame for plotting, using the row names for the legend
#plot_data <- data.frame(
#  Configuration = rep(column_names, times = 4),
#  Value = c(as.numeric(indexes[1, ]), as.numeric(indexes[2, ]),
#            as.numeric(indexes[3, ]), as.numeric(indexes[4, ])),
#  Line = rep(row_names, each = length(column_names))  # Use row names for the legend)
#filename_dbi_plot<-paste0("Diabetes_DBI_Plot.pdf")
#pdf(filename_dbi_plot)
# Create the plot, using color to distinguish the lines and row names in the legend
#ggplot(plot_data, aes(x = Configuration, y = Value, color = Line)) +
#  geom_point() +
#  labs(x = "Clustering algorithm", y = "DBI result", title = "Davies-Bouldin Index Evaluations", color="DBI Configuration") +
#  theme_grey()+
#  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels by 45 degrees
#dev.off()
# Print the DBI results for the second row
# Convert only the second row into a format suitable for plotting
rows_to_plot <- indexes[2, , drop = FALSE]  # Extract only the second row
column_names <- colnames(indexes)  # Get the column names (from kmeans2 onwards)
# Get the actual row name for the second row
row_name <- rownames(indexes)[2]
# Create a data frame for plotting, using the row name for the legend
plot_data <- data.frame(
Configuration = column_names,  # Use the column names as x-axis labels
Value = as.numeric(indexes[2, ]),  # Use the second row for the values
Line = rep(row_name, length(column_names))  # Use the second row's name for the legend
)
# Specify the filename for the PDF output
filename_dbi_plot <- paste0("Diabetes_DBI_Plot.pdf")
pdf(filename_dbi_plot)
# Create the plot
ggplot(plot_data, aes(x = Configuration, y = Value)) +
geom_bar(stat = "identity") +
labs(x = "Clustering algorithm", y = "DBI result", title = "Davies-Bouldin Index Evaluations", color = "DBI Configuration") +
theme_grey() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 14),  # Rotate x-axis labels by 45 degrees and set font size
plot.title = element_text(size = 20),       # Title font size
axis.title.x = element_text(size = 16),     # X axis label font size
axis.title.y = element_text(size = 16),     # Y axis label font size
axis.text.y = element_text(size = 14),      # Y axis tick labels font size
legend.title = element_text(size = 16),     # Legend title font size
legend.text = element_text(size = 14)       # Legend text font size
)
dev.off()
#Exctract information DBI uses
extracted_info <- extract_clustering_info(mydata, labels)
# Open a connection to a text file
#Script where I load an EHRs document(depression_heart_failure) and apply the kmeans clustering
#and my DBI function. Then I save everything on a couple of csv files
#I had to get rid of id column since it didnt make any sense with the clustering
#Loading data
mydata0<-read.csv("depression_heart_failure.csv")
#Getting rid of id column
mydata<-mydata0[,2:ncol(mydata0)]
#getting kmeans labels
km_labels<-kmeans_labels(mydata)
#getting hclust labels
hc_labels<-hclust_labels(mydata)
#Getting dbscan parameters
eps<- 60              #radius
minPts<-8           #minimal number of neighbours
#Setting the case
case <- "Heart_failure"
#getting dbscan labels
dbsc_lab<-dbscan_labels(mydata,eps,minPts,case)
# Calculate the four indexes
indexes<-DBI_EHRs(mydata,km_labels,hc_labels,dbsc_lab)
#binding clusterings for printing
labels<-list(mydata,km_labels,hc_labels,dbsc_lab)
#Find the highest DBI scores
highest_DBI_result <- find_highest_DBI(indexes)
#Calculate cardinality of clusters
cardinality_proportions <- calculate_cardinality_proportion(mydata,km_labels,hc_labels,dbsc_lab)
#Print and plot the result
filename_percentages<-paste0("depression_heart_failure_cluster_percentages_Plot.pdf")
pdf(filename_percentages)
plot_cluster_percentages(cardinality_proportions)
dev.off()
#Compare clusterings in a chart
compare_clusterings(labels)
#Print the DBI results
# Convert the first four rows into a format suitable for plotting
#rows_to_plot <- indexes[1:4, ]  # Extract the first four rows
#column_names <- colnames(indexes)  # Get the column names (from kmeans2 onwards)
# Get the actual row names from the data frame
#row_names <- rownames(indexes)[1:4]
# Create a data frame for plotting, using the row names for the legend
#plot_data <- data.frame(
#  Configuration = rep(column_names, times = 4),
#  Value = c(as.numeric(indexes[1, ]), as.numeric(indexes[2, ]),
#            as.numeric(indexes[3, ]), as.numeric(indexes[4, ])),
#  Line = rep(row_names, each = length(column_names))  # Use row names for the legend)
#filename_dbi_plot<-paste0("Depression_HeartFailure_DBI_Plot.pdf")
#pdf(filename_dbi_plot)
# Create the plot, using color to distinguish the lines and row names in the legend
#ggplot(plot_data, aes(x = Configuration, y = Value, color = Line)) +
#  geom_point() +
#  labs(x = "Clustering algorithm", y = "DBI result", title = "Davies-Bouldin Index Evaluations", color="DBI Configuration") +
#  theme_grey()+
#  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels by 45 degrees
#dev.off()
# Print the DBI results for the second row
# Convert only the second row into a format suitable for plotting
rows_to_plot <- indexes[2, , drop = FALSE]  # Extract only the second row
column_names <- colnames(indexes)  # Get the column names (from kmeans2 onwards)
# Get the actual row name for the second row
row_name <- rownames(indexes)[2]
# Create a data frame for plotting, using the row name for the legend
plot_data <- data.frame(
Configuration = column_names,  # Use the column names as x-axis labels
Value = as.numeric(indexes[2, ]),  # Use the second row for the values
Line = rep(row_name, length(column_names))  # Use the second row's name for the legend
)
# Specify the filename for the PDF output
filename_dbi_plot <- paste0("Depression_HeartFailure_DBI_Plot.pdf")
pdf(filename_dbi_plot)
# Create the plot
ggplot(plot_data, aes(x = Configuration, y = Value)) +
geom_bar(stat = "identity") +
labs(x = "Clustering algorithm", y = "DBI result", title = "Davies-Bouldin Index Evaluations", color = "DBI Configuration") +
theme_grey() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 14),  # Rotate x-axis labels by 45 degrees and set font size
plot.title = element_text(size = 20),       # Title font size
axis.title.x = element_text(size = 16),     # X axis label font size
axis.title.y = element_text(size = 16),     # Y axis label font size
axis.text.y = element_text(size = 14),      # Y axis tick labels font size
legend.title = element_text(size = 16),     # Legend title font size
legend.text = element_text(size = 14)       # Legend text font size
)
dev.off()
#Exctract information DBI uses
extracted_info <- extract_clustering_info(mydata, labels)
# Open a connection to a text file
sink("Depression_Heart_Failure_info.txt")
# Print the result
print(highest_DBI_result)
# Print cardinality proportions
print(cardinality_proportions)
# Print the information
print(extracted_info)
# Close the connection
sink()
# Add name for saving!! This is the data csv print
write.csv(labels, file="Depression_Heart_Failure+labels.csv")
# Add name for saving!! This is the DBI evaluation csv print
write.csv(indexes, file="Depression_Heart_Failure_DBI.csv")
describe_clustering_result(highest_DBI_result,3)
#Script where I load an EHRs document(neuroblastoma) and apply
#the clustering algorithms and my DBI function.
#Then I save everything on a couple of csv files
#I had to get rid of several void rows in the end of the file
#Loading data
mydata<-read.csv("neuroblastoma.csv")
#getting kmeans labels
km_labels<-kmeans_labels(mydata)
#getting hclust labels
hc_labels<-hclust_labels(mydata)
#Getting dbscan parameters
eps<- 3              #radius
minPts<-10           #minimal number of neighbours
#Setting the case
case <- "Neuroblastoma"
#getting dbscan labels
dbsc_lab<-dbscan_labels(mydata,eps,minPts,case)
# Calculate the four indexes
indexes<-DBI_EHRs(mydata,km_labels,hc_labels,dbsc_lab)
#binding clusterings for printing
labels<-list(mydata,km_labels,hc_labels,dbsc_lab)
#Find the highest DBI scores
highest_DBI_result <- find_highest_DBI(indexes)
#Calculate cardinality of clusters
cardinality_proportions <- calculate_cardinality_proportion(mydata,km_labels,hc_labels,dbsc_lab)
#Print and plot the result
filename_percentages<-paste0("Neuroblastoma_cluster_percentages_Plot.pdf")
pdf(filename_percentages)
plot_cluster_percentages(cardinality_proportions)
dev.off()
#Compare clusterings in a chart
compare_clusterings(labels)
#Print the DBI results
# Convert the first four rows into a format suitable for plotting
#rows_to_plot <- indexes[1:4, ]  # Extract the first four rows
#column_names <- colnames(indexes)  # Get the column names (from kmeans2 onwards)
# Get the actual row names from the data frame
#row_names <- rownames(indexes)[1:4]
# Create a data frame for plotting, using the row names for the legend
#plot_data <- data.frame(
#  Configuration = rep(column_names, times = 4),
#  Value = c(as.numeric(indexes[1, ]), as.numeric(indexes[2, ]),
#            as.numeric(indexes[3, ]), as.numeric(indexes[4, ])),
#  Line = rep(row_names, each = length(column_names))  # Use row names for the legend)
#filename_dbi_plot<-paste0("Neuroblastoma_DBI_Plot.pdf")
#pdf(filename_dbi_plot)
# Create the plot, using color to distinguish the lines and row names in the legend
#ggplot(plot_data, aes(x = Configuration, y = Value, color = Line)) +
#  geom_point() +
#  labs(x = "Clustering algorithm", y = "DBI result", title = "Davies-Bouldin Index Evaluations", color="DBI Configuration") +
#  theme_grey()+
#  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels by 45 degrees
#dev.off()
# Print the DBI results for the second row
# Convert only the second row into a format suitable for plotting
rows_to_plot <- indexes[2, , drop = FALSE]  # Extract only the second row
column_names <- colnames(indexes)  # Get the column names (from kmeans2 onwards)
# Get the actual row name for the second row
row_name <- rownames(indexes)[2]
# Create a data frame for plotting, using the row name for the legend
plot_data <- data.frame(
Configuration = column_names,  # Use the column names as x-axis labels
Value = as.numeric(indexes[2, ]),  # Use the second row for the values
Line = rep(row_name, length(column_names))  # Use the second row's name for the legend
)
# Specify the filename for the PDF output
filename_dbi_plot <- paste0("Neuroblastoma_DBI_Plot.pdf")
pdf(filename_dbi_plot)
# Create the plot
ggplot(plot_data, aes(x = Configuration, y = Value)) +
geom_bar(stat = "identity") +
labs(x = "Clustering algorithm", y = "DBI result", title = "Davies-Bouldin Index Evaluations", color = "DBI Configuration") +
theme_grey() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 14),  # Rotate x-axis labels by 45 degrees and set font size
plot.title = element_text(size = 20),       # Title font size
axis.title.x = element_text(size = 16),     # X axis label font size
axis.title.y = element_text(size = 16),     # Y axis label font size
axis.text.y = element_text(size = 14),      # Y axis tick labels font size
legend.title = element_text(size = 16),     # Legend title font size
legend.text = element_text(size = 14)       # Legend text font size
)
dev.off()
#Exctract information DBI uses
extracted_info <- extract_clustering_info(mydata, labels)
# Open a connection to a text file
sink("Neuroblastoma_info.txt")
# Print the result
print(highest_DBI_result)
# Print cardinality proportions
print(cardinality_proportions)
# Print the information
print(extracted_info)
# Close the connection
sink()
# Add name for saving!! This is the data csv print
write.csv(labels, file="Neuroblastoma+labels.csv")
# Add name for saving!! This is the DBI evaluation csv print
write.csv(indexes, file="Neuroblastoma_DBI.csv")
describe_clustering_result(highest_DBI_result,4)
#Script where I load an EHRs document(Sepsis) and apply the kmeans clustering
#and my DBI function. Then I save everything on a couple of csv files
#Loading data
mydata<-read.csv("Sepsis.csv")
#getting kmeans labels
km_labels<-kmeans_labels(mydata)
#getting hclust labels
hc_labels<-hclust_labels(mydata)
#Getting dbscan parameters(I struggled to find better ones)
eps<- 30              #radius
minPts<-10            #minimal number of neighbours
#Setting the case
case <- "Sepsis"
#getting dbscan labels
dbsc_lab<-dbscan_labels(mydata,eps,minPts,case)
# Calculate the four indexes
indexes<-DBI_EHRs(mydata,km_labels,hc_labels,dbsc_lab)
#binding clusterings for printing
labels<-list(mydata,km_labels,hc_labels,dbsc_lab)
#Calculate cardinality of clusters
cardinality_proportions <- calculate_cardinality_proportion(mydata,km_labels,hc_labels,dbsc_lab)
#Print and plot the result
filename_percentages<-paste0("Sepsis_cluster_percentages_Plot.pdf")
pdf(filename_percentages)
plot_cluster_percentages(cardinality_proportions)
dev.off()
#Compare clusterings in a chart
compare_clusterings(labels)
#Print the DBI results
# Convert the first four rows into a format suitable for plotting
#rows_to_plot <- indexes[1:4, ]  # Extract the first four rows
#column_names <- colnames(indexes)  # Get the column names (from kmeans2 onwards)
# Get the actual row names from the data frame
#row_names <- rownames(indexes)[1:4]
# Create a data frame for plotting, using the row names for the legend
#plot_data <- data.frame(
#  Configuration = rep(column_names, times = 4),
#  Value = c(as.numeric(indexes[1, ]), as.numeric(indexes[2, ]),
#            as.numeric(indexes[3, ]), as.numeric(indexes[4, ])),
#  Line = rep(row_names, each = length(column_names))  # Use row names for the legend)
#filename_dbi_plot<-paste0("Sepsis_DBI_Plot.pdf")
#pdf(filename_dbi_plot)
# Create the plot, using color to distinguish the lines and row names in the legend
#ggplot(plot_data, aes(x = Configuration, y = Value, color = Line)) +
#  geom_point() +
#  labs(x = "Clustering algorithm", y = "DBI result", title = "Davies-Bouldin Index Evaluations", color="DBI Configuration") +
#  theme_grey()+
#  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels by 45 degrees
#dev.off()
# Print the DBI results for the second row
# Convert only the second row into a format suitable for plotting
rows_to_plot <- indexes[2, , drop = FALSE]  # Extract only the second row
column_names <- colnames(indexes)  # Get the column names (from kmeans2 onwards)
# Get the actual row name for the second row
row_name <- rownames(indexes)[2]
# Create a data frame for plotting, using the row name for the legend
plot_data <- data.frame(
Configuration = column_names,  # Use the column names as x-axis labels
Value = as.numeric(indexes[2, ]),  # Use the second row for the values
Line = rep(row_name, length(column_names))  # Use the second row's name for the legend
)
# Specify the filename for the PDF output
filename_dbi_plot <- paste0("Sepsis_DBI_Plot.pdf")
pdf(filename_dbi_plot)
# Create the plot
ggplot(plot_data, aes(x = Configuration, y = Value)) +
geom_bar(stat = "identity") +
labs(x = "Clustering algorithm", y = "DBI result", title = "Davies-Bouldin Index Evaluations", color = "DBI Configuration") +
theme_grey() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 14),  # Rotate x-axis labels by 45 degrees and set font size
plot.title = element_text(size = 20),       # Title font size
axis.title.x = element_text(size = 16),     # X axis label font size
axis.title.y = element_text(size = 16),     # Y axis label font size
axis.text.y = element_text(size = 14),      # Y axis tick labels font size
legend.title = element_text(size = 16),     # Legend title font size
legend.text = element_text(size = 14)       # Legend text font size
)
dev.off()
#Exctract information DBI uses
extracted_info <- extract_clustering_info(mydata, labels)
#Find the highest DBI scores
highest_DBI_result <- find_highest_DBI(indexes)
# Open a connection to a text file
sink("Sepsis_info.txt")
# Print the result
print(highest_DBI_result)
# Print cardinality proportions
print(cardinality_proportions)
# Print the information
print(extracted_info)
# Close the connection
sink()
# Add name for saving!! This is the data csv print
write.csv(labels, file="Sepsis+labels.csv")
# Add name for saving!! This is the DBI evaluation csv print
write.csv(indexes, file="Sepsis_DBI.csv")
describe_clustering_result(highest_DBI_result,5)

# Assign the new cluster (Cluster 4) to Cluster 2
data <- data.frame(
x = c(x1, x2, x3, x4),
y = c(y1, y2, y3, y4),
cluster = factor(c(rep("Cluster 1", n_points),
rep("Cluster 2", n_points),
rep("Cluster 3", n_points),
rep("Cluster 2", n_points)))  # Merge Cluster 4 into Cluster 2
)
DBIndexes <- function(data, clusters) {
#I need to "process" the data before
newdata <- as.matrix(data)
newdata <- apply(newdata, 2, as.double)
newdata <-t(newdata)
cl <- as.integer(clusters)
scatter_data <- cls.scatt.data(t(newdata), cl, dist = "euclidean")
#Calculation indexes
db_index_avg <- clv.Davies.Bouldin(scatter_data, intracls = "average", intercls = "centroid")
#I want three digits after comma
db_index_avg <- format( db_index_avg, nsmall = 3, digits = 3, scientific = FALSE)
# Return as a named data frame
return(db_index_avg)
}
# Apply the DBIndexes function
result <- DBIndexes(data[, 1:2], data$cluster)
# Prepare results for display
result_text <- paste("Davies-Bouldin Index:", result)
# Create the plot with a grey theme
plot <- ggplot(data, aes(x = x, y = y, color = cluster)) +
geom_point(alpha = 0.7) +
theme_minimal(base_family = "Arial") +
theme(panel.background = element_rect(fill = "grey", color = NA)) +
labs(title = "Clusters with Merged Cloud",
x = "X-coordinate",
y = "Y-coordinate",
color = "Cluster") +
coord_equal()
# Create a text grob for the result
result_grob <- grid::textGrob(result_text, gp = grid::gpar(fontsize = 14, fontfamily = "Arial"))
# Arrange the plot and the result
gridExtra::grid.arrange(plot, result_grob, ncol = 1, heights = c(3, 1))
# Set seed for reproducibility
set.seed(42)
# Parameters for the three clusters
n_points <- 200                # Number of points per cluster
means <- list(c(2, 0.5), c(-20, 0), c(2, -0.5))  # Centroids of the clusters
sd <- 0.5                      # Standard deviation for all clusters
# Generate points for each cluster
x1 <- rnorm(n_points, mean = means[[1]][1], sd = sd)
y1 <- rnorm(n_points, mean = means[[1]][2], sd = sd)
x2 <- rnorm(n_points, mean = means[[2]][1], sd = sd)
y2 <- rnorm(n_points, mean = means[[2]][2], sd = sd)
x3 <- rnorm(n_points, mean = means[[3]][1], sd = sd)
y3 <- rnorm(n_points, mean = means[[3]][2], sd = sd)
# Combine the three clusters into a data frame
data <- data.frame(
x = c(x1, x2, x3),
y = c(y1, y2, y3),
cluster = factor(c(rep("Cluster 1", n_points),
rep("Cluster 2", n_points),
rep("Cluster 3", n_points)))
)
DBIndexes <- function(data, clusters) {
#I need to "process" the data before
newdata <- as.matrix(data)
newdata <- apply(newdata, 2, as.double)
newdata <-t(newdata)
cl <- as.integer(clusters)
scatter_data <- cls.scatt.data(t(newdata), cl, dist = "euclidean")
#Calculation indexes
db_index_avg <- clv.Davies.Bouldin(scatter_data, intracls = "average", intercls = "centroid")
#I want three digits after comma
db_index_avg <- format( db_index_avg, nsmall = 3, digits = 3, scientific = FALSE)
# Return as a named data frame
return(db_index_avg)
}
# Apply the DBIndexes function
result <- DBIndexes(data[, 1:2], data$cluster)
# Prepare results for display
result_text <- paste("Davies-Bouldin Index:", result)
# Create the plot with a grey theme
plot <- ggplot(data, aes(x = x, y = y, color = cluster)) +
geom_point(alpha = 0.7) +
theme_minimal(base_family = "Arial") +
theme(panel.background = element_rect(fill = "grey", color = NA)) +
labs(title = "Two Distinct Clusters",
x = "X-coordinate",
y = "Y-coordinate",
color = "Cluster") +
coord_equal()
# Create a text grob for the result
result_grob <- grid::textGrob(result_text, gp = grid::gpar(fontsize = 14, fontfamily = "Arial"))
# Arrange the plot and the result
gridExtra::grid.arrange(plot, result_grob, ncol = 1, heights = c(3, 1))
# Set seed for reproducibility
set.seed(42)
# Parameters for the four clusters
n_points <- 200                # Number of points per cluster
means <- list(c(2, 0.5), c(-20, 0), c(2, -0.5), c(-5, -2))  # Centroids of the clusters
sd <- 0.5                      # Standard deviation for all clusters
# Generate points for each cluster
x1 <- rnorm(n_points, mean = means[[1]][1], sd = sd)
y1 <- rnorm(n_points, mean = means[[1]][2], sd = sd)
x2 <- rnorm(n_points, mean = means[[2]][1], sd = sd)
y2 <- rnorm(n_points, mean = means[[2]][2], sd = sd)
x3 <- rnorm(n_points, mean = means[[3]][1], sd = sd)
y3 <- rnorm(n_points, mean = means[[3]][2], sd = sd)
x4 <- rnorm(n_points, mean = means[[4]][1], sd = sd)
y4 <- rnorm(n_points, mean = means[[4]][2], sd = sd)
# Combine the four clusters into a data frame
# Assign the new cluster (Cluster 4) to Cluster 2
data <- data.frame(
x = c(x1, x2, x3, x4),
y = c(y1, y2, y3, y4),
cluster = factor(c(rep("Cluster 1", n_points),
rep("Cluster 2", n_points),
rep("Cluster 3", n_points),
rep("Cluster 2", n_points)))  # Merge Cluster 4 into Cluster 2
)
DBIndexes <- function(data, clusters) {
#I need to "process" the data before
newdata <- as.matrix(data)
newdata <- apply(newdata, 2, as.double)
newdata <-t(newdata)
cl <- as.integer(clusters)
scatter_data <- cls.scatt.data(t(newdata), cl, dist = "euclidean")
#Calculation indexes
db_index_avg <- clv.Davies.Bouldin(scatter_data, intracls = "average", intercls = "centroid")
#I want three digits after comma
db_index_avg <- format( db_index_avg, nsmall = 3, digits = 3, scientific = FALSE)
# Return as a named data frame
return(db_index_avg)
}
# Apply the DBIndexes function
result <- DBIndexes(data[, 1:2], data$cluster)
# Prepare results for display
result_text <- paste("Davies-Bouldin Index:", result)
# Create the plot with a grey theme
plot <- ggplot(data, aes(x = x, y = y, color = cluster)) +
geom_point(alpha = 0.7) +
theme_minimal(base_family = "Arial") +
theme(panel.background = element_rect(fill = "grey", color = NA)) +
labs(title = "Clusters with Merged Cloud",
x = "X-coordinate",
y = "Y-coordinate",
color = "Cluster") +
coord_equal()
# Create a text grob for the result
result_grob <- grid::textGrob(result_text, gp = grid::gpar(fontsize = 14, fontfamily = "Arial"))
# Arrange the plot and the result
gridExtra::grid.arrange(plot, result_grob, ncol = 1, heights = c(3, 1))
# Set seed for reproducibility
set.seed(42)
# Parameters for the four clusters
n_points <- 200                # Number of points per cluster
means <- list(c(2, 0.5), c(-20, 0), c(2, -0.5), c(-5, -2))  # Centroids of the clusters
sd <- 0.5                      # Standard deviation for all clusters
# Generate points for each cluster
x1 <- rnorm(n_points, mean = means[[1]][1], sd = sd)
y1 <- rnorm(n_points, mean = means[[1]][2], sd = sd)
x2 <- rnorm(n_points, mean = means[[2]][1], sd = sd)
y2 <- rnorm(n_points, mean = means[[2]][2], sd = sd)
x3 <- rnorm(n_points, mean = means[[3]][1], sd = sd)
y3 <- rnorm(n_points, mean = means[[3]][2], sd = sd)
x4 <- rnorm(n_points, mean = means[[4]][1], sd = sd)
y4 <- rnorm(n_points, mean = means[[4]][2], sd = sd)
# Combine the four clusters into a data frame
# Assign the new cluster (Cluster 4) to Cluster 3
data <- data.frame(
x = c(x1, x2, x3, x4),
y = c(y1, y2, y3, y4),
cluster = factor(c(rep("Cluster 1", n_points),
rep("Cluster 2", n_points),
rep("Cluster 3", n_points),
rep("Cluster 3", n_points)))  # Merge Cluster 4 into Cluster 3
)
DBIndexes <- function(data, clusters) {
#I need to "process" the data before
newdata <- as.matrix(data)
newdata <- apply(newdata, 2, as.double)
newdata <-t(newdata)
cl <- as.integer(clusters)
scatter_data <- cls.scatt.data(t(newdata), cl, dist = "euclidean")
#Calculation indexes
db_index_avg <- clv.Davies.Bouldin(scatter_data, intracls = "average", intercls = "centroid")
#I want three digits after comma
db_index_avg <- format( db_index_avg, nsmall = 3, digits = 3, scientific = FALSE)
# Return as a named data frame
return(db_index_avg)
}
# Apply the DBIndexes function
result <- DBIndexes(data[, 1:2], data$cluster)
# Prepare results for display
result_text <- paste("Davies-Bouldin Index:", result)
# Create the plot with a grey theme
plot <- ggplot(data, aes(x = x, y = y, color = cluster)) +
geom_point(alpha = 0.7) +
theme_minimal(base_family = "Arial") +
theme(panel.background = element_rect(fill = "grey", color = NA)) +
labs(title = "Clusters with Merged Cloud",
x = "X-coordinate",
y = "Y-coordinate",
color = "Cluster") +
coord_equal()
# Create a text grob for the result
result_grob <- grid::textGrob(result_text, gp = grid::gpar(fontsize = 14, fontfamily = "Arial"))
# Arrange the plot and the result
gridExtra::grid.arrange(plot, result_grob, ncol = 1, heights = c(3, 1))
source("~/GitHub/DBI-guide/bin/Clusters with Merged Cloud2.R")
source("~/GitHub/DBI-guide/bin/Example - Clusters with Merged Cloud.R")
source("~/GitHub/DBI-guide/bin/Clusters with Merged Cloud2.R")
source("~/GitHub/DBI-guide/bin/Example - Clusters with Merged Cloud2.R")
# Set seed for reproducibility
set.seed(42)
# Parameters for the four clusters
n_points <- 200                # Number of points per cluster
means <- list(c(2, 0.5), c(-20, 0), c(2, -0.5), c(-5, -2))  # Centroids of the clusters
sd <- 0.5                      # Standard deviation for all clusters
# Generate points for each cluster
x1 <- rnorm(n_points, mean = means[[1]][1], sd = sd)
y1 <- rnorm(n_points, mean = means[[1]][2], sd = sd)
x2 <- rnorm(n_points, mean = means[[2]][1], sd = sd)
y2 <- rnorm(n_points, mean = means[[2]][2], sd = sd)
x3 <- rnorm(n_points, mean = means[[3]][1], sd = sd)
y3 <- rnorm(n_points, mean = means[[3]][2], sd = sd)
x4 <- rnorm(n_points, mean = means[[4]][1], sd = sd)
y4 <- rnorm(n_points, mean = means[[4]][2], sd = sd)
# Combine the four clusters into a data frame
# Assign the extreme left ball (Cluster 2) to Cluster 3, while the new middle ball stays in Cluster 2
data <- data.frame(
x = c(x1, x2, x3, x4),
y = c(y1, y2, y3, y4),
cluster = factor(c(rep("Cluster 1", n_points),
rep("Cluster 3", n_points),  # Move extreme left ball to Cluster 3
rep("Cluster 3", n_points),  # Keep original Cluster 3
rep("Cluster 2", n_points)))  # Keep new middle ball in Cluster 2
)
DBIndexes <- function(data, clusters) {
#I need to "process" the data before
newdata <- as.matrix(data)
newdata <- apply(newdata, 2, as.double)
newdata <-t(newdata)
cl <- as.integer(clusters)
scatter_data <- cls.scatt.data(t(newdata), cl, dist = "euclidean")
#Calculation indexes
db_index_avg <- clv.Davies.Bouldin(scatter_data, intracls = "average", intercls = "centroid")
#I want three digits after comma
db_index_avg <- format( db_index_avg, nsmall = 3, digits = 3, scientific = FALSE)
# Return as a named data frame
return(db_index_avg)
}
# Apply the DBIndexes function
result <- DBIndexes(data[, 1:2], data$cluster)
# Prepare results for display
result_text <- paste("Davies-Bouldin Index:", result)
# Create the plot with a grey theme
plot <- ggplot(data, aes(x = x, y = y, color = cluster)) +
geom_point(alpha = 0.7) +
theme_minimal(base_family = "Arial") +
theme(panel.background = element_rect(fill = "grey", color = NA)) +
labs(title = "Clusters with Adjusted Assignments",
x = "X-coordinate",
y = "Y-coordinate",
color = "Cluster") +
coord_equal()
# Create a text grob for the result
result_grob <- grid::textGrob(result_text, gp = grid::gpar(fontsize = 14, fontfamily = "Arial"))
# Arrange the plot and the result
gridExtra::grid.arrange(plot, result_grob, ncol = 1, heights = c(3, 1))
source("~/GitHub/DBI-guide/bin/Example - Clusters with Merged Cloud3.R")
# Set seed for reproducibility
set.seed(42)
# Parameters for the three clusters
n_points <- 200                # Number of points per cluster
means <- list(c(2, 0.5), c(-20, 0), c(2, -0.5))  # Centroids of the clusters
sd <- 0.5                      # Standard deviation for all clusters
# Generate points for each cluster
x1 <- rnorm(n_points, mean = means[[1]][1], sd = sd)
y1 <- rnorm(n_points, mean = means[[1]][2], sd = sd)
x2 <- rnorm(n_points, mean = means[[2]][1], sd = sd)
y2 <- rnorm(n_points, mean = means[[2]][2], sd = sd)
x3 <- rnorm(n_points, mean = means[[3]][1], sd = sd)
y3 <- rnorm(n_points, mean = means[[3]][2], sd = sd)
# Combine the three clusters into a data frame
data <- data.frame(
x = c(x1, x2, x3),
y = c(y1, y2, y3),
cluster = factor(c(rep("Cluster 1", n_points),
rep("Cluster 2", n_points),
rep("Cluster 3", n_points)))
)
# Update labels to merge Cluster 2 and Cluster 3
data$cluster <- factor(ifelse(data$cluster == "Cluster 3", "Cluster 2", as.character(data$cluster)))
DBIndexes <- function(data, clusters) {
#I need to "process" the data before
newdata <- as.matrix(data)
newdata <- apply(newdata, 2, as.double)
newdata <-t(newdata)
cl <- as.integer(clusters)
scatter_data <- cls.scatt.data(t(newdata), cl, dist = "euclidean")
#Calculation indexes
db_index_avg <- clv.Davies.Bouldin(scatter_data, intracls = "average", intercls = "centroid")
#I want three digits after comma
db_index_avg <- format( db_index_avg, nsmall = 3, digits = 3, scientific = FALSE)
# Return as a named data frame
return(db_index_avg)
}
# Apply the DBIndexes function
result <- DBIndexes(data[, 1:2], data$cluster)
# Prepare results for display
result_text <- paste("Davies-Bouldin Index:", result)
# Create the plot with a grey theme
plot <- ggplot(data, aes(x = x, y = y, color = cluster)) +
geom_point(alpha = 0.7) +
theme_minimal(base_family = "Arial") +
theme(panel.background = element_rect(fill = "grey", color = NA)) +
labs(title = "Two Distinct Clusters",
x = "X-coordinate",
y = "Y-coordinate",
color = "Cluster") +
coord_equal()
# Create a text grob for the result
result_grob <- grid::textGrob(result_text, gp = grid::gpar(fontsize = 14, fontfamily = "Arial"))
# Arrange the plot and the result
gridExtra::grid.arrange(plot, result_grob, ncol = 1, heights = c(3, 1))
# Set seed for reproducibility
set.seed(42)
# Parameters for the two splashed clusters along the line
n_points <- 200             # Number of points per cluster
line_sd <- 0.3              # Spread along the line
line_range <- 1.5           # Range along the line (to make clusters closer)
line_offset <- 1.7         # Smaller offset to make them even closer
# First splashed cluster along the x-axis (Cluster 1)
x1 <- rnorm(n_points, mean = line_range, sd = line_sd)
y1 <- rnorm(n_points, mean = 0, sd = 0.1)  # Small spread along the line
# Second splashed cluster along the x-axis (Cluster 2)
x2 <- rnorm(n_points, mean = line_range - line_offset, sd = line_sd)
y2 <- rnorm(n_points, mean = 0, sd = 0.1)  # Small spread along the line
# Parameters for the round orthogonal cluster (Cluster 3)
radius <- 1.0                # Radius of the round cluster (making it a ball)
center_x <- 0                # Center x-coordinate (away from the line)
center_y <- 4                # Center y-coordinate (away from the line)
round_sd <- 0.2              # Spread in all directions for roundness
# Generate points for the round orthogonal cluster (Cluster 3)
x3 <- rnorm(n_points, mean = center_x, sd = round_sd)
y3 <- rnorm(n_points, mean = center_y, sd = round_sd)
# Combine the three clusters into a data frame
data <- data.frame(
x = c(x1, x2, x3),
y = c(y1, y2, y3),
cluster = factor(c(rep("Cluster 1", n_points),
rep("Cluster 2", n_points),
rep("Cluster 3", n_points)))
)
# Apply the DBIndexes function
result <- DBIndexes(data[, 1:2], data$cluster)
# Prepare results for display
result_text <- paste("Davies-Bouldin Index:", result)
# Create the plot with a grey theme
plot <- ggplot(data, aes(x = x, y = y, color = cluster)) +
geom_point(alpha = 0.7) +
theme_minimal(base_family = "Arial") +
theme(panel.background = element_rect(fill = "grey", color = NA)) +
labs(title = "Two Distinct Clusters",
x = "X-coordinate",
y = "Y-coordinate",
color = "Cluster") +
coord_equal()
# Create a text grob for the result
result_grob <- grid::textGrob(result_text, gp = grid::gpar(fontsize = 14, fontfamily = "Arial"))
# Arrange the plot and the result
gridExtra::grid.arrange(plot, result_grob, ncol = 1, heights = c(3, 1))
# Set seed for reproducibility
set.seed(42)
# Parameters for the two splashed clusters along the line
n_points <- 200             # Number of points per cluster
line_sd <- 0.3              # Spread along the line
line_range <- 1.5           # Range along the line (to make clusters closer)
line_offset <- 1.7         # Smaller offset to make them even closer
# First splashed cluster along the x-axis (Cluster 1)
x1 <- rnorm(n_points, mean = line_range, sd = line_sd)
y1 <- rnorm(n_points, mean = 0, sd = 0.1)  # Small spread along the line
# Second splashed cluster along the x-axis (Cluster 2)
x2 <- rnorm(n_points, mean = line_range - line_offset, sd = line_sd)
y2 <- rnorm(n_points, mean = 0, sd = 0.1)  # Small spread along the line
# Parameters for the round orthogonal cluster (Cluster 3)
radius <- 1.0                # Radius of the round cluster (making it a ball)
center_x <- 0                # Center x-coordinate (away from the line)
center_y <- 4                # Center y-coordinate (away from the line)
round_sd <- 0.2              # Spread in all directions for roundness
# Generate points for the round orthogonal cluster (Cluster 3)
x3 <- rnorm(n_points, mean = center_x, sd = round_sd)
y3 <- rnorm(n_points, mean = center_y, sd = round_sd)
# Combine the clusters into a data frame
data <- data.frame(
x = c(x1, x2, x3),
y = c(y1, y2, y3),
cluster = factor(c(rep("Cluster 1", n_points),
rep("Cluster 1", n_points),  # Changed Cluster 2 to Cluster 1
rep("Cluster 3", n_points)))
)
# Apply the DBIndexes function
result <- DBIndexes(data[, 1:2], data$cluster)
# Prepare results for display
result_text <- paste("Davies-Bouldin Index:", result)
# Create the plot with a grey theme
plot <- ggplot(data, aes(x = x, y = y, color = cluster)) +
geom_point(alpha = 0.7) +
theme_minimal(base_family = "Arial") +
theme(panel.background = element_rect(fill = "grey", color = NA)) +
labs(title = "Two Distinct Clusters",
x = "X-coordinate",
y = "Y-coordinate",
color = "Cluster") +
coord_equal()
# Create a text grob for the result
result_grob <- grid::textGrob(result_text, gp = grid::gpar(fontsize = 14, fontfamily = "Arial"))
# Arrange the plot and the result
gridExtra::grid.arrange(plot, result_grob, ncol = 1, heights = c(3, 1))
# Set seed for reproducibility
set.seed(42)
# Parameters for the two splashed clusters along the line
n_points <- 200             # Number of points per cluster
line_sd <- 0.3              # Spread along the line
line_range <- 1.5           # Range along the line (to make clusters closer)
line_offset <- 1.5         # Smaller offset to make them even closer
# First splashed cluster along the x-axis (Cluster 1)
x1 <- rnorm(n_points, mean = line_range, sd = line_sd)
y1 <- rnorm(n_points, mean = 0, sd = 0.1)  # Small spread along the line
# Second splashed cluster along the x-axis (Cluster 2)
x2 <- rnorm(n_points, mean = line_range - line_offset, sd = line_sd)
y2 <- rnorm(n_points, mean = 0, sd = 0.1)  # Small spread along the line
# Parameters for the round orthogonal cluster (Cluster 3)
radius <- 1.0                # Radius of the round cluster (making it a ball)
center_x <- 0                # Center x-coordinate (away from the line)
center_y <- 4                # Center y-coordinate (away from the line)
round_sd <- 0.2              # Spread in all directions for roundness
# Generate points for the round orthogonal cluster (Cluster 3)
x3 <- rnorm(n_points, mean = center_x, sd = round_sd)
y3 <- rnorm(n_points, mean = center_y, sd = round_sd)
# Combine the three clusters into a data frame
data <- data.frame(
x = c(x1, x2, x3),
y = c(y1, y2, y3),
cluster = factor(c(rep("Cluster 1", n_points),
rep("Cluster 2", n_points),
rep("Cluster 3", n_points)))
)
# Apply the DBIndexes function
result <- DBIndexes(data[, 1:2], data$cluster)
# Prepare results for display
result_text <- paste("Davies-Bouldin Index:", result)
# Create the plot with a grey theme
plot <- ggplot(data, aes(x = x, y = y, color = cluster)) +
geom_point(alpha = 0.7) +
theme_minimal(base_family = "Arial") +
theme(panel.background = element_rect(fill = "grey", color = NA)) +
labs(title = "Two Distinct Clusters",
x = "X-coordinate",
y = "Y-coordinate",
color = "Cluster") +
coord_equal()
# Create a text grob for the result
result_grob <- grid::textGrob(result_text, gp = grid::gpar(fontsize = 14, fontfamily = "Arial"))
# Arrange the plot and the result
gridExtra::grid.arrange(plot, result_grob, ncol = 1, heights = c(3, 1))
# Set seed for reproducibility
set.seed(42)
# Parameters for the two splashed clusters along the line
n_points <- 200             # Number of points per cluster
line_sd <- 0.3              # Spread along the line
line_range <- 1.5           # Range along the line (to make clusters closer)
line_offset <- 1.5         # Smaller offset to make them even closer
# First splashed cluster along the x-axis (Cluster 1)
x1 <- rnorm(n_points, mean = line_range, sd = line_sd)
y1 <- rnorm(n_points, mean = 0, sd = 0.1)  # Small spread along the line
# Second splashed cluster along the x-axis (Cluster 2)
x2 <- rnorm(n_points, mean = line_range - line_offset, sd = line_sd)
y2 <- rnorm(n_points, mean = 0, sd = 0.1)  # Small spread along the line
# Parameters for the round orthogonal cluster (Cluster 3)
radius <- 1.0                # Radius of the round cluster (making it a ball)
center_x <- 0                # Center x-coordinate (away from the line)
center_y <- 4                # Center y-coordinate (away from the line)
round_sd <- 0.2              # Spread in all directions for roundness
# Generate points for the round orthogonal cluster (Cluster 3)
x3 <- rnorm(n_points, mean = center_x, sd = round_sd)
y3 <- rnorm(n_points, mean = center_y, sd = round_sd)
# Combine the clusters into a data frame, merging Cluster 1 and Cluster 2
x_combined <- c(x1, x2, x3)
y_combined <- c(y1, y2, y3)
clusters_combined <- factor(c(rep("Cluster 1", 2 * n_points),  # Merge Cluster 1 and 2
rep("Cluster 2", n_points)))  # Rename Cluster 3 to Cluster 2
data <- data.frame(x = x_combined, y = y_combined, cluster = clusters_combined)
# Apply the DBIndexes function
result <- DBIndexes(data[, 1:2], data$cluster)
# Prepare results for display
result_text <- paste("Davies-Bouldin Index:", result)
# Create the plot with a grey theme
plot <- ggplot(data, aes(x = x, y = y, color = cluster)) +
geom_point(alpha = 0.7) +
theme_minimal(base_family = "Arial") +
theme(panel.background = element_rect(fill = "grey", color = NA)) +
labs(title = "Two Fused Clusters",
x = "X-coordinate",
y = "Y-coordinate",
color = "Cluster") +
coord_equal()
# Create a text grob for the result
result_grob <- grid::textGrob(result_text, gp = grid::gpar(fontsize = 14, fontfamily = "Arial"))
# Arrange the plot and the result
gridExtra::grid.arrange(plot, result_grob, ncol = 1, heights = c(3, 1))
source("~/GitHub/DBI-guide/bin/Example-Max Dissonance6.R")
